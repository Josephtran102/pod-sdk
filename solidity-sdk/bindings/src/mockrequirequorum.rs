/**

Generated by the following Solidity interface...
```solidity
interface MockRequireQuorum {
    fallback() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "nonpayable"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockRequireQuorum {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600f57600080fd5b506103748061001f6000396000f3fe608060405234801561001057600080fd5b5060003660606000838381019061002791906101dd565b90506100686040518060400160405280600a81526020017f636f6e646974696f6e3a00000000000000000000000000000000000000000000815250826100b4565b806100a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161009f90610267565b60405180910390fd5b50915050805190602001f35b61014c82826040516024016100ca929190610315565b6040516020818303038152906040527fc3b55635000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050610150565b5050565b6101678161015f61016a61018b565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610196819050919050565b61019e610345565b565b600080fd5b60008115159050919050565b6101ba816101a5565b81146101c557600080fd5b50565b6000813590506101d7816101b1565b92915050565b6000602082840312156101f3576101f26101a0565b5b6000610201848285016101c8565b91505092915050565b600082825260208201905092915050565b7f51756f72756d20726571756972656d656e74206e6f74206d6574000000000000600082015250565b6000610251601a8361020a565b915061025c8261021b565b602082019050919050565b6000602082019050818103600083015261028081610244565b9050919050565b600081519050919050565b60005b838110156102b0578082015181840152602081019050610295565b60008484015250505050565b6000601f19601f8301169050919050565b60006102d882610287565b6102e2818561020a565b93506102f2818560208601610292565b6102fb816102bc565b840191505092915050565b61030f816101a5565b82525050565b6000604082019050818103600083015261032f81856102cd565b905061033e6020830184610306565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[Pa\x03t\x80a\0\x1F`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x006```\0\x83\x83\x81\x01\x90a\0'\x91\x90a\x01\xDDV[\x90Pa\0h`@Q\x80`@\x01`@R\x80`\n\x81R` \x01\x7Fcondition:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x82a\0\xB4V[\x80a\0\xA8W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\0\x9F\x90a\x02gV[`@Q\x80\x91\x03\x90\xFD[P\x91PP\x80Q\x90` \x01\xF3[a\x01L\x82\x82`@Q`$\x01a\0\xCA\x92\x91\x90a\x03\x15V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7F\xC3\xB5V5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x83\x16\x17\x83RPPPPa\x01PV[PPV[a\x01g\x81a\x01_a\x01ja\x01\x8BV[c\xFF\xFF\xFF\xFF\x16V[PV[`\0jconsole.log\x90P`\0\x80\x83Q` \x85\x01\x84Z\xFAPPPV[a\x01\x96\x81\x90P\x91\x90PV[a\x01\x9Ea\x03EV[V[`\0\x80\xFD[`\0\x81\x15\x15\x90P\x91\x90PV[a\x01\xBA\x81a\x01\xA5V[\x81\x14a\x01\xC5W`\0\x80\xFD[PV[`\0\x815\x90Pa\x01\xD7\x81a\x01\xB1V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x01\xF3Wa\x01\xF2a\x01\xA0V[[`\0a\x02\x01\x84\x82\x85\x01a\x01\xC8V[\x91PP\x92\x91PPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FQuorum requirement not met\0\0\0\0\0\0`\0\x82\x01RPV[`\0a\x02Q`\x1A\x83a\x02\nV[\x91Pa\x02\\\x82a\x02\x1BV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x02\x80\x81a\x02DV[\x90P\x91\x90PV[`\0\x81Q\x90P\x91\x90PV[`\0[\x83\x81\x10\x15a\x02\xB0W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x02\x95V[`\0\x84\x84\x01RPPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x02\xD8\x82a\x02\x87V[a\x02\xE2\x81\x85a\x02\nV[\x93Pa\x02\xF2\x81\x85` \x86\x01a\x02\x92V[a\x02\xFB\x81a\x02\xBCV[\x84\x01\x91PP\x92\x91PPV[a\x03\x0F\x81a\x01\xA5V[\x82RPPV[`\0`@\x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x03/\x81\x85a\x02\xCDV[\x90Pa\x03>` \x83\x01\x84a\x03\x06V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`Q`\x04R`$`\0\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b5060003660606000838381019061002791906101dd565b90506100686040518060400160405280600a81526020017f636f6e646974696f6e3a00000000000000000000000000000000000000000000815250826100b4565b806100a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161009f90610267565b60405180910390fd5b50915050805190602001f35b61014c82826040516024016100ca929190610315565b6040516020818303038152906040527fc3b55635000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050610150565b5050565b6101678161015f61016a61018b565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610196819050919050565b61019e610345565b565b600080fd5b60008115159050919050565b6101ba816101a5565b81146101c557600080fd5b50565b6000813590506101d7816101b1565b92915050565b6000602082840312156101f3576101f26101a0565b5b6000610201848285016101c8565b91505092915050565b600082825260208201905092915050565b7f51756f72756d20726571756972656d656e74206e6f74206d6574000000000000600082015250565b6000610251601a8361020a565b915061025c8261021b565b602082019050919050565b6000602082019050818103600083015261028081610244565b9050919050565b600081519050919050565b60005b838110156102b0578082015181840152602081019050610295565b60008484015250505050565b6000601f19601f8301169050919050565b60006102d882610287565b6102e2818561020a565b93506102f2818560208601610292565b6102fb816102bc565b840191505092915050565b61030f816101a5565b82525050565b6000604082019050818103600083015261032f81856102cd565b905061033e6020830184610306565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x006```\0\x83\x83\x81\x01\x90a\0'\x91\x90a\x01\xDDV[\x90Pa\0h`@Q\x80`@\x01`@R\x80`\n\x81R` \x01\x7Fcondition:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x82a\0\xB4V[\x80a\0\xA8W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\0\x9F\x90a\x02gV[`@Q\x80\x91\x03\x90\xFD[P\x91PP\x80Q\x90` \x01\xF3[a\x01L\x82\x82`@Q`$\x01a\0\xCA\x92\x91\x90a\x03\x15V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7F\xC3\xB5V5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x83\x16\x17\x83RPPPPa\x01PV[PPV[a\x01g\x81a\x01_a\x01ja\x01\x8BV[c\xFF\xFF\xFF\xFF\x16V[PV[`\0jconsole.log\x90P`\0\x80\x83Q` \x85\x01\x84Z\xFAPPPV[a\x01\x96\x81\x90P\x91\x90PV[a\x01\x9Ea\x03EV[V[`\0\x80\xFD[`\0\x81\x15\x15\x90P\x91\x90PV[a\x01\xBA\x81a\x01\xA5V[\x81\x14a\x01\xC5W`\0\x80\xFD[PV[`\0\x815\x90Pa\x01\xD7\x81a\x01\xB1V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x01\xF3Wa\x01\xF2a\x01\xA0V[[`\0a\x02\x01\x84\x82\x85\x01a\x01\xC8V[\x91PP\x92\x91PPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FQuorum requirement not met\0\0\0\0\0\0`\0\x82\x01RPV[`\0a\x02Q`\x1A\x83a\x02\nV[\x91Pa\x02\\\x82a\x02\x1BV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x02\x80\x81a\x02DV[\x90P\x91\x90PV[`\0\x81Q\x90P\x91\x90PV[`\0[\x83\x81\x10\x15a\x02\xB0W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x02\x95V[`\0\x84\x84\x01RPPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x02\xD8\x82a\x02\x87V[a\x02\xE2\x81\x85a\x02\nV[\x93Pa\x02\xF2\x81\x85` \x86\x01a\x02\x92V[a\x02\xFB\x81a\x02\xBCV[\x84\x01\x91PP\x92\x91PPV[a\x03\x0F\x81a\x01\xA5V[\x82RPPV[`\0`@\x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x03/\x81\x85a\x02\xCDV[\x90Pa\x03>` \x83\x01\x84a\x03\x06V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`Q`\x04R`$`\0\xFD",
    );
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockRequireQuorum`](self) contract instance.

See the [wrapper's documentation](`MockRequireQuorumInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockRequireQuorumInstance<T, P, N> {
        MockRequireQuorumInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockRequireQuorumInstance<T, P, N>>,
    > {
        MockRequireQuorumInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockRequireQuorumInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockRequireQuorum`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockRequireQuorum`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockRequireQuorumInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockRequireQuorumInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockRequireQuorumInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockRequireQuorum`](self) contract instance.

See the [wrapper's documentation](`MockRequireQuorumInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockRequireQuorumInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockRequireQuorumInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockRequireQuorumInstance<T, P, N> {
            MockRequireQuorumInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
