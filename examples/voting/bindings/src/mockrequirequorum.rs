/**

Generated by the following Solidity interface...
```solidity
interface MockRequireQuorum {
    fallback() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "nonpayable"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockRequireQuorum {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600f57600080fd5b506103658061001f6000396000f3fe608060405234801561001057600080fd5b506000803681019061002291906101ce565b90506100636040518060400160405280601981526020017f6d6f636b20707265636f6d70696c652072656365697665643a00000000000000815250826100a5565b806100a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161009a90610258565b60405180910390fd5b005b61013d82826040516024016100bb929190610306565b6040516020818303038152906040527fc3b55635000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050610141565b5050565b6101588161015061015b61017c565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610187819050919050565b61018f610336565b565b600080fd5b60008115159050919050565b6101ab81610196565b81146101b657600080fd5b50565b6000813590506101c8816101a2565b92915050565b6000602082840312156101e4576101e3610191565b5b60006101f2848285016101b9565b91505092915050565b600082825260208201905092915050565b7f71756f72756d206e6f74206d6574000000000000000000000000000000000000600082015250565b6000610242600e836101fb565b915061024d8261020c565b602082019050919050565b6000602082019050818103600083015261027181610235565b9050919050565b600081519050919050565b60005b838110156102a1578082015181840152602081019050610286565b60008484015250505050565b6000601f19601f8301169050919050565b60006102c982610278565b6102d381856101fb565b93506102e3818560208601610283565b6102ec816102ad565b840191505092915050565b61030081610196565b82525050565b6000604082019050818103600083015261032081856102be565b905061032f60208301846102f7565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[Pa\x03e\x80a\0\x1F`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\0\x806\x81\x01\x90a\0\"\x91\x90a\x01\xCEV[\x90Pa\0c`@Q\x80`@\x01`@R\x80`\x19\x81R` \x01\x7Fmock precompile received:\0\0\0\0\0\0\0\x81RP\x82a\0\xA5V[\x80a\0\xA3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\0\x9A\x90a\x02XV[`@Q\x80\x91\x03\x90\xFD[\0[a\x01=\x82\x82`@Q`$\x01a\0\xBB\x92\x91\x90a\x03\x06V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7F\xC3\xB5V5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x83\x16\x17\x83RPPPPa\x01AV[PPV[a\x01X\x81a\x01Pa\x01[a\x01|V[c\xFF\xFF\xFF\xFF\x16V[PV[`\0jconsole.log\x90P`\0\x80\x83Q` \x85\x01\x84Z\xFAPPPV[a\x01\x87\x81\x90P\x91\x90PV[a\x01\x8Fa\x036V[V[`\0\x80\xFD[`\0\x81\x15\x15\x90P\x91\x90PV[a\x01\xAB\x81a\x01\x96V[\x81\x14a\x01\xB6W`\0\x80\xFD[PV[`\0\x815\x90Pa\x01\xC8\x81a\x01\xA2V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x01\xE4Wa\x01\xE3a\x01\x91V[[`\0a\x01\xF2\x84\x82\x85\x01a\x01\xB9V[\x91PP\x92\x91PPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fquorum not met\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0\x82\x01RPV[`\0a\x02B`\x0E\x83a\x01\xFBV[\x91Pa\x02M\x82a\x02\x0CV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x02q\x81a\x025V[\x90P\x91\x90PV[`\0\x81Q\x90P\x91\x90PV[`\0[\x83\x81\x10\x15a\x02\xA1W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x02\x86V[`\0\x84\x84\x01RPPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x02\xC9\x82a\x02xV[a\x02\xD3\x81\x85a\x01\xFBV[\x93Pa\x02\xE3\x81\x85` \x86\x01a\x02\x83V[a\x02\xEC\x81a\x02\xADV[\x84\x01\x91PP\x92\x91PPV[a\x03\0\x81a\x01\x96V[\x82RPPV[`\0`@\x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x03 \x81\x85a\x02\xBEV[\x90Pa\x03/` \x83\x01\x84a\x02\xF7V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`Q`\x04R`$`\0\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b506000803681019061002291906101ce565b90506100636040518060400160405280601981526020017f6d6f636b20707265636f6d70696c652072656365697665643a00000000000000815250826100a5565b806100a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161009a90610258565b60405180910390fd5b005b61013d82826040516024016100bb929190610306565b6040516020818303038152906040527fc3b55635000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050610141565b5050565b6101588161015061015b61017c565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610187819050919050565b61018f610336565b565b600080fd5b60008115159050919050565b6101ab81610196565b81146101b657600080fd5b50565b6000813590506101c8816101a2565b92915050565b6000602082840312156101e4576101e3610191565b5b60006101f2848285016101b9565b91505092915050565b600082825260208201905092915050565b7f71756f72756d206e6f74206d6574000000000000000000000000000000000000600082015250565b6000610242600e836101fb565b915061024d8261020c565b602082019050919050565b6000602082019050818103600083015261027181610235565b9050919050565b600081519050919050565b60005b838110156102a1578082015181840152602081019050610286565b60008484015250505050565b6000601f19601f8301169050919050565b60006102c982610278565b6102d381856101fb565b93506102e3818560208601610283565b6102ec816102ad565b840191505092915050565b61030081610196565b82525050565b6000604082019050818103600083015261032081856102be565b905061032f60208301846102f7565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\0\x806\x81\x01\x90a\0\"\x91\x90a\x01\xCEV[\x90Pa\0c`@Q\x80`@\x01`@R\x80`\x19\x81R` \x01\x7Fmock precompile received:\0\0\0\0\0\0\0\x81RP\x82a\0\xA5V[\x80a\0\xA3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\0\x9A\x90a\x02XV[`@Q\x80\x91\x03\x90\xFD[\0[a\x01=\x82\x82`@Q`$\x01a\0\xBB\x92\x91\x90a\x03\x06V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7F\xC3\xB5V5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x83\x16\x17\x83RPPPPa\x01AV[PPV[a\x01X\x81a\x01Pa\x01[a\x01|V[c\xFF\xFF\xFF\xFF\x16V[PV[`\0jconsole.log\x90P`\0\x80\x83Q` \x85\x01\x84Z\xFAPPPV[a\x01\x87\x81\x90P\x91\x90PV[a\x01\x8Fa\x036V[V[`\0\x80\xFD[`\0\x81\x15\x15\x90P\x91\x90PV[a\x01\xAB\x81a\x01\x96V[\x81\x14a\x01\xB6W`\0\x80\xFD[PV[`\0\x815\x90Pa\x01\xC8\x81a\x01\xA2V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x01\xE4Wa\x01\xE3a\x01\x91V[[`\0a\x01\xF2\x84\x82\x85\x01a\x01\xB9V[\x91PP\x92\x91PPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fquorum not met\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0\x82\x01RPV[`\0a\x02B`\x0E\x83a\x01\xFBV[\x91Pa\x02M\x82a\x02\x0CV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x02q\x81a\x025V[\x90P\x91\x90PV[`\0\x81Q\x90P\x91\x90PV[`\0[\x83\x81\x10\x15a\x02\xA1W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x02\x86V[`\0\x84\x84\x01RPPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x02\xC9\x82a\x02xV[a\x02\xD3\x81\x85a\x01\xFBV[\x93Pa\x02\xE3\x81\x85` \x86\x01a\x02\x83V[a\x02\xEC\x81a\x02\xADV[\x84\x01\x91PP\x92\x91PPV[a\x03\0\x81a\x01\x96V[\x82RPPV[`\0`@\x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x03 \x81\x85a\x02\xBEV[\x90Pa\x03/` \x83\x01\x84a\x02\xF7V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`Q`\x04R`$`\0\xFD",
    );
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockRequireQuorum`](self) contract instance.

See the [wrapper's documentation](`MockRequireQuorumInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockRequireQuorumInstance<T, P, N> {
        MockRequireQuorumInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockRequireQuorumInstance<T, P, N>>,
    > {
        MockRequireQuorumInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockRequireQuorumInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockRequireQuorum`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockRequireQuorum`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockRequireQuorumInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockRequireQuorumInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockRequireQuorumInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockRequireQuorum`](self) contract instance.

See the [wrapper's documentation](`MockRequireQuorumInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockRequireQuorumInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockRequireQuorumInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockRequireQuorumInstance<T, P, N> {
            MockRequireQuorumInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRequireQuorumInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
